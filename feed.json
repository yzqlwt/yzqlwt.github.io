{"title":"玄离的博客","description":"华中科技大学09级，就职于腾讯SNG。擅长各项前端技能，深入研究移动端开发与前端性能。非专业视觉设计师。此为博客一枚。","language":"","link":"http://blog.yzqlwt.com","pubDate":"Mon, 16 Dec 2019 10:15:00 GMT","lastBuildDate":"Mon, 16 Dec 2019 11:35:24 GMT","generator":"hexo-generator-json-feed","webMaster":"玄离","items":[{"title":"EventListenerTouchOneByOne的小问题","link":"http://blog.yzqlwt.com/archives/503970b4.html","description":"EventListenerTouchOneByOne的小问题 触摸响应区域是整个屏幕 触摸穿透的设置（SetSwallowTouches） 对象隐藏事件依旧会响应 示例代码（lua）1234567891011local listener = cc.EventListenerTouchOneByOne:create(); listener:setSwallowTouches(true) listener:registerScriptHandler(function(touch, event) if self:isVisible() and self:isAncestorsVisible(self) and cc.rectContainsPoint(self:getBoundingBox(), touch) then doCallback(callback, target) return true end return false end, cc.Handler.EVENT_TOUCH_BEGAN);local eventDispatcher = self:getEventDispatcher(); eventDispatcher:addEventListenerWithSceneGraphPriority(listener, self); 12345678910function Node:isAncestorsVisible(node) if not node then return true end parent = node:getParent() if parent and not parent:isVisible() then return false end return self:isAncestorsVisible(parent)end 代码分析 isAncestorsVisible: 判断子节点在场景中是否可见 setSwallowTouches的使用看查看setSwallowTouches详解，setSwallowTouches设置为true，即事件不向低优先级的listener传递。代码第四行的判断，判断此节点是否可见&amp;&amp;是否在场景中可见&amp;&amp;点击位置是否在节点内部则返回true。如果返回false则setSwallowTouches无效，事件继续传递。 cc.rectContainsPoint(self:getBoundingBox(), touch)判断点击位置是否在对象内部","pubDate":"Mon, 16 Dec 2019 10:15:00 GMT","guid":"http://blog.yzqlwt.com/archives/503970b4.html","category":"Cocos"},{"title":"SetSwallowTouches","link":"http://blog.yzqlwt.com/archives/25c1596b.html","description":"Cocos SetSwallowTouches详解当想要停止触摸事件继续向后面的订阅者分发，可以使用SetSwallowTouches(true)来实现。 swallowTouches设置需要在onTouchBegan返回true的时候才有效 为什么只有在onTouchBegan返回true的时候才生效看一下CCEventDispatcher.cpp中的dispatchTouchEvent函数就明白了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107if (oneByOneListeners) &#123; auto mutableTouchesIter = mutableTouches.begin(); auto touchesIter = originalTouches.begin(); for (; touchesIter != originalTouches.end(); ++touchesIter) &#123; bool isSwallowed = false; auto onTouchEvent = [&amp;](EventListener* l) -&gt; bool &#123; // Return true to break EventListenerTouchOneByOne* listener = static_cast&lt;EventListenerTouchOneByOne*&gt;(l); // Skip if the listener was removed. if (!listener-&gt;_isRegistered) return false; event-&gt;setCurrentTarget(listener-&gt;_node); bool isClaimed = false; std::vector&lt;Touch*&gt;::iterator removedIter; EventTouch::EventCode eventCode = event-&gt;getEventCode(); if (eventCode == EventTouch::EventCode::BEGAN) &#123; if (listener-&gt;onTouchBegan) &#123; isClaimed = listener-&gt;onTouchBegan(*touchesIter, event); if (isClaimed &amp;&amp; listener-&gt;_isRegistered) &#123; listener-&gt;_claimedTouches.push_back(*touchesIter); &#125; &#125; &#125; else if (listener-&gt;_claimedTouches.size() &gt; 0 &amp;&amp; ((removedIter = std::find(listener-&gt;_claimedTouches.begin(), listener-&gt;_claimedTouches.end(), *touchesIter)) != listener-&gt;_claimedTouches.end())) &#123; isClaimed = true; switch (eventCode) &#123; case EventTouch::EventCode::MOVED: if (listener-&gt;onTouchMoved) &#123; listener-&gt;onTouchMoved(*touchesIter, event); &#125; break; case EventTouch::EventCode::ENDED: if (listener-&gt;onTouchEnded) &#123; listener-&gt;onTouchEnded(*touchesIter, event); &#125; if (listener-&gt;_isRegistered) &#123; listener-&gt;_claimedTouches.erase(removedIter); &#125; break; case EventTouch::EventCode::CANCELLED: if (listener-&gt;onTouchCancelled) &#123; listener-&gt;onTouchCancelled(*touchesIter, event); &#125; if (listener-&gt;_isRegistered) &#123; listener-&gt;_claimedTouches.erase(removedIter); &#125; break; default: CCASSERT(false, \"The eventcode is invalid.\"); break; &#125; &#125; // If the event was stopped, return directly. if (event-&gt;isStopped()) &#123; updateListeners(event); return true; &#125; CCASSERT((*touchesIter)-&gt;getID() == (*mutableTouchesIter)-&gt;getID(), \"touchesIter ID should be equal to mutableTouchesIter's ID.\"); if (isClaimed &amp;&amp; listener-&gt;_isRegistered &amp;&amp; listener-&gt;_needSwallow) &#123; if (isNeedsMutableSet) &#123; mutableTouchesIter = mutableTouches.erase(mutableTouchesIter); isSwallowed = true; &#125; return true; &#125; return false; &#125;; // dispatchTouchEventToListeners(oneByOneListeners, onTouchEvent); if (event-&gt;isStopped()) &#123; return; &#125; if (!isSwallowed) ++mutableTouchesIter; &#125; &#125; 我们来分析一下这段代码 点击屏幕，派发点击事件，调用dispatchTouchEvent 遍历所有注册是touch事件，获取listener 通过 EventTouch::EventCode eventCode = event-&gt;getEventCode();获取Touch类型 如果是EventTouch::EventCode::BEGAN执行onTouchBegan,取得返回值isClaimed(这个值很重要) if(isClaimed &amp;&amp; listener-&gt;_isRegistered &amp;&amp; listener-&gt;_needSwallow listener-&gt;_needSwallow是SetSwallowTouches设置的值。同时满足onTouchBegan的返回值为true和listener-&gt;_needSwallow等于true，移除mutableTouchesIter(相当于移除所有的事件监听)，mutableTouchesIter是拷贝而来的不会影响下次的事件相应。 为什么onTouchBegan返回false，onTouchMove等就不会被执行了呢 再来看上面的代码，第35行 需要满足listener-&gt;_claimedTouches.size() &gt; 0才会进入onTouchMove等函数。isClaimed 为true的时候，才会对_claimedTouches添加成员。 所以onTouchBegan决定了onTouchMove等函数会不会被执行","pubDate":"Mon, 16 Dec 2019 09:12:00 GMT","guid":"http://blog.yzqlwt.com/archives/25c1596b.html","category":""},{"title":"MazeGeneration","link":"http://blog.yzqlwt.com/archives/6492a9c4.html","description":"迷宫生成N*N的网格，按照预设的路线，生成唯一解的迷宫。迷宫可上下左右四个方向移动，每个网格都有颜色，必须按照红-黄-蓝-绿（颜色种类可预设）的顺序走。 网格节点 节点的颜色(Type) 节点的行列名字(Name), “Mesh_2_1”第2行第1列节点 是否被访问过(IsVisited) 父节点(MeshNode) 1234567891011121314class MeshNode&#123; public int Type &#123; get; set; &#125; public string Name &#123; get; set; &#125; public MeshNode PreNode &#123; get; set; &#125; public bool IsVisited &#123; get; set; &#125; public MeshNode(int type, string name) &#123; Type = type; Name = name; PreNode = null; IsVisited = false; &#125;&#125; 算法实现 构建一个N*N的迷宫，随机生成每个网格的Type. 修改在预设路径上网格节点的Type. 从预设路径的开始节点进行深度优先搜索. 1.判断是否到终点，是则跳出 2.对此节点获取临近节点，筛选临近节点中可以走的节点，没有可以走的就跳出 3.通过筛选的节点，IsVisited设置为true, preNode设置为步骤2的节点，然后进行dfs，跳出dfs后IsVisited设置为false 每次搜索到终点时，终点与起点是一条单向链表。将此路径保存起来. 所有的路径收集完成后，是一个网格节点的集合。筛选出不在预设路径中的点. 修改每个节点的Type. 重复进行搜索所有的路径。如果只有一条路径，则跳出。如果还有则继续修改节点Type，重复搜索. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206using System;using System.Collections.Generic;using System.Linq;class MeshNode&#123; public int Type &#123; get; set; &#125; public string Name &#123; get; set; &#125; public MeshNode PreNode &#123; get; set; &#125; public bool IsVisited &#123; get; set; &#125; public MeshNode(int type, string name) &#123; Type = type; Name = name; PreNode = null; IsVisited = false; &#125;&#125;class MazeTools&#123; public int MazeSize &#123; get; set; &#125; public int TypesCount &#123; get; set; &#125; public List&lt;MeshNode&gt; MazeNodes = new List&lt;MeshNode&gt;(); public MeshNode startMeshNode &#123; get; set; &#125; public MeshNode endMeshNode &#123; get; set; &#125; public List&lt;string&gt; AllRouters = new List&lt;string&gt;(); public void initMeshData() &#123; var size = MazeSize; var typesCount = TypesCount; Random random = new Random(); for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; var node = new MeshNode(random.Next(typesCount), \"mesh_\" + i + \"_\" + j); MazeNodes.Add(node); &#125; &#125; modifyPresetMesh(); &#125; public List&lt;MeshNode&gt; getPresetMeshNodes() &#123; string[] array = &#123; \"mesh_1_0\", \"mesh_1_1\", \"mesh_1_2\", \"mesh_1_3\", \"mesh_1_4\", \"mesh_2_4\", \"mesh_3_4\", \"mesh_3_3\", \"mesh_3_2\", \"mesh_3_1\"&#125;; List&lt;MeshNode&gt; nodes = new List&lt;MeshNode&gt;(); for (int i = 0; i &lt; array.Count(); i++)&#123; nodes.Add(new MeshNode( i%TypesCount,array[i])); &#125; return nodes; &#125; public void modifyPresetMesh() &#123; var mazeNodes = MazeNodes; var presetMeshNode = getPresetMeshNodes(); foreach (var node in presetMeshNode) &#123; var mazeNode = mazeNodes.Find(delegate (MeshNode meshnode) &#123; return node.Name == meshnode.Name; &#125;); if (mazeNode != null) &#123; mazeNode.Type = node.Type; &#125; &#125; Console.WriteLine(\"modifyPresetMesh ok！\"); startMeshNode = presetMeshNode.First(); endMeshNode = presetMeshNode.Last(); &#125; public MeshNode getMeshNodeByName(string name) &#123; return MazeNodes.Find(delegate (MeshNode meshnode) &#123; return meshnode.Name == name; &#125;); &#125; public List&lt;MeshNode&gt; getNeighbors(MeshNode node) &#123; var name = node.Name; var arr = name.Split('_'); int row = int.Parse(arr[1]); int col = int.Parse(arr[2]); var leftNode = getMeshNodeByName(\"mesh_\" + row + '_' + (col - 1)); var rightNode = getMeshNodeByName(\"mesh_\" + row + '_' + (col + 1)); var upNode = getMeshNodeByName(\"mesh_\" + (row - 1) + '_' + col); var downNode = getMeshNodeByName(\"mesh_\" + (row + 1) + '_' + col); var nodes = new List&lt;MeshNode&gt;(); nodes.Add(leftNode); nodes.Add(rightNode); nodes.Add(upNode); nodes.Add(downNode); nodes = nodes.Where(n =&gt; n != null).ToList(); return nodes; &#125; public void getAllRoutes() &#123; var node = startMeshNode; node.IsVisited = true; dfs(node); node.IsVisited = false; if (AllRouters.Count != 1) &#123; Console.WriteLine(\"存在&#123;0&#125;条路径可以到达终点，正在尝试修正！\", AllRouters.Count); reviseRoutes(); resetData(); getAllRoutes(); &#125; else &#123; Console.WriteLine(\"done!\"); &#125; &#125; public void resetData() &#123; MazeNodes.ForEach(node =&gt; &#123; node.IsVisited = false; &#125;); AllRouters.Clear(); &#125; public void reviseRoutes() &#123; var routes = AllRouters; var presetMeshnodes = getPresetMeshNodes(); var array = new List&lt;string&gt;(); routes.ForEach(route =&gt; &#123; var arr = route.Split('+'); var list = arr .Where(name =&gt; &#123; return null == presetMeshnodes.Find(delegate (MeshNode n) &#123; return n.Name == name; &#125;); &#125;) .ToList(); array.AddRange(list); &#125;); array .Distinct() .ToList() .ForEach(name =&gt; &#123; var node = getMeshNodeByName(name); Random random = new Random(); var newType = random.Next(TypesCount); var oldType = node.Type; newType = newType != oldType ? newType : getNextType(node); node.Type = newType; Console.WriteLine(\"修正节点&#123;0&#125;Type: from &#123;1&#125; to &#123;2&#125;\", node.Name, oldType, newType); &#125;); Console.WriteLine(\"修正节点完成，准备进行测试...\"); &#125; public int getNextType(MeshNode node) &#123; var type = node.Type; return (type + 1) % TypesCount; &#125; public void addPath(MeshNode node) &#123; string route = node.Name; while (node.PreNode != null) &#123; route = route + '+' + node.PreNode.Name; node = node.PreNode; &#125; AllRouters.Add(route); &#125; public void dfs(MeshNode node) &#123; if (node.Name == endMeshNode.Name) &#123; addPath(node); return; &#125; var nextType = getNextType(node); var neighbors = getNeighbors(node); neighbors .Where(neigh =&gt; !neigh.IsVisited) .Where(neigh =&gt; neigh.Type == nextType) .ToList() .ForEach(neigh =&gt; &#123; neigh.IsVisited = true; neigh.PreNode = node; dfs(neigh); neigh.IsVisited = false; &#125;); &#125;&#125;","pubDate":"Wed, 11 Sep 2019 02:13:31 GMT","guid":"http://blog.yzqlwt.com/archives/6492a9c4.html","category":"算法,C#"}]}